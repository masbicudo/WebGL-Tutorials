<head>
    <title>#4 Composition of distance fields</title>
    <script type="text/javascript" src="../lib/gl-matrix.js"></script>
    <script type="text/javascript" src="../lib/mdn-getShader.js"></script>
</head>
<body onload="javascript:startWebGLApp()">
    <canvas id="canvas" style="border:none" width="600" height="800" />
</body>
<script type="text/javascript">
    "use strict";

    function startWebGLApp() {
        var gl = getWebGLContext("canvas");
        var programs = {
            fragShader: getShader("fragment-shader"),
            vertexShader: getShader("vertex-shader")
        };
        var programParams = initShaders(gl);
        var shape = createSquare(gl);
        gl.clearColor(0, 0, 0, 1);
        draw(gl, shape, programParams);
    }

    function getWebGLContext(id) {
        var canvasElement = document.getElementById(id);
        try {
            var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            return gl;
        }
        catch(e) {}
        return;
    }

    function initShaders(gl) {
        var fragmentShader = getShader(gl, "fragment-shader");
        var vertexShader = getShader(gl, "vertex-shader");

        // Creating shader program
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialize shaders.");
        }

        gl.useProgram(shaderProgram);

        var aVertexCoords = gl.getAttribLocation(shaderProgram, "aVertexCoords");
        gl.enableVertexAttribArray(aVertexCoords);

        var uTransform = gl.getUniformLocation(shaderProgram, "uTransform");

        return {
            aVertexCoords: aVertexCoords,
            uTransform: uTransform
        };
    }

    function createSquare(gl) {
        var squareVertexCoordBuffer = gl.createBuffer();
        var coorsdArray = [
            -1,  1, // 1st point
             1,  1, // 2nd point
            -1, -1, // 3rd point
             1, -1  // 4th point
        ];
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coorsdArray), gl.STATIC_DRAW);
        return {
            coordsBuffer: squareVertexCoordBuffer,
            coorsdArray: coorsdArray,
            pointCount: 4,
            pointSize: 2
        };
    }

    function draw(gl, shape, programParams) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        var transformMatrix = [
            0.6,   0,   0,   0,
              0, 0.8,   0,   0,
              0,   0,   1,   0,
              0,   0,   0,   1
        ];
        gl.uniformMatrix4fv(programParams.uTransform, false, transformMatrix);

        // setting the current buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, shape.coordsBuffer);

        // associate attribute 'aVertexCoords' with current buffer
        gl.vertexAttribPointer(programParams.aVertexCoords, 2, gl.FLOAT, false, 0, 0);

        // draw triangles, using the shaders of the current program, with the current attributes
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, shape.pointCount);
    }

</script>
<script id="fragment-shader" type="x-shader/x-fragment">
  precision highp float;
  const int NUM_STEPS = 128;
  const float PIX_DIFF = 1./512.;
  const float DIST_DIFF = 1./1024.;
  const float LIGHT_AMBIENT = 0.075;
  const vec3 LIGHT_POINT = vec3(-1.0, 1.0, -1.0);
  const float MATERIAL_SHINESS = 5.;
  const float LIGHT_INTENSITY = 8.;

  varying vec4 pos;

  float distSphere(vec3 p, vec3 c, float r) {
    return length(p - c) - r;
  }

  float distFunc(vec3 v) {
    const mat4 T = mat4(
         1. , 0. , 0. , 0. ,
         0. , 1. , 0. , 0. ,
         0. , 0. , 1. , 0. ,
        -0.21,-0.21, 0.21 , 1.
    );
    vec3 v2 = (T * vec4(v,1.)).xyz;
    return min(
            max(
                distSphere(v, vec3(0.0, 0.0, 2.0), 0.5),
                -distSphere(v, vec3(0.4, 0.4, 1.6), 0.5)
            ),
            max(
                distSphere(v2, vec3(0.0, 0.0, 2.0), 0.5),
                distSphere(v2, vec3(0.4, 0.4, 1.6), 0.5)
            )
        );
  }
  
  void mainIterations(void) {
    vec3 p = vec3(pos.xy, 0.0);
    int steps = 0;
    for (int i = 0; i < NUM_STEPS; i++) {
        steps++;
        float dist = distFunc(p);
        p = vec3(p.xy, p.z + dist);
        if (dist < DIST_DIFF) {
            break;
        }
    }
    gl_FragColor = vec4(vec3(float(steps)/float(NUM_STEPS)), 1.0);
  }

  void main(void) {
    //mainIterations(); return;
    vec3 p = vec3(pos.xy, 0.0);
    int steps = 0;
    vec3 normal = vec3(0.0, 0.0, 0.0);
    
    for (int i = 0; i < NUM_STEPS; i++) {
        steps++;
        float dist = distFunc(p);
        if (dist < DIST_DIFF) {
            vec3 pX = vec3(p.x+PIX_DIFF, p.y, p.z);
            vec3 pY = vec3(p.x, p.y+PIX_DIFF, p.z);
            vec3 pZ = vec3(p.x, p.y, p.z+PIX_DIFF);
            float distX = distFunc(pX);
            float distY = distFunc(pY);
            float distZ = distFunc(pZ);

            // this will give the surface normal for the fragment
            normal = normalize(vec3(distX-dist, distY-dist, distZ-dist));

            break;
        }
        p = vec3(p.xy, p.z + dist);
    }

    if (steps == NUM_STEPS) {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
        // Diffuse
        vec3 lightPos = LIGHT_POINT;
        vec3 lightDir = (lightPos - p);
        float lightIntensity = LIGHT_INTENSITY / dot(lightDir, lightDir);
        lightDir = normalize(lightDir);
        float diffuse = max(dot(normal, lightDir), 0.0);

        // Specular
        vec3 viewDir = normalize(vec3(pos.xy, 0.0) - p);
        vec3 reflectDir = reflect(-lightDir, normal);
        float specular = pow(max(dot(viewDir, reflectDir), 0.0), MATERIAL_SHINESS);

        float lightness = clamp((specular + diffuse) * lightIntensity + LIGHT_AMBIENT, 0.0, 1.0);
        gl_FragColor = vec4(lightness, lightness, lightness, 1.0);
    }
  }

  float map(float value, float low1, float high1, float low2, float high2) {
    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);
  }
</script>
<script id="vertex-shader" type="x-shader/x-vertex">
  attribute vec2 aVertexCoords;
  varying vec4 pos;
  uniform mat4 uTransform;

  void main(void) {
    gl_Position = vec4(aVertexCoords, 0.0, 1.0);
    pos = uTransform * gl_Position * 1.5;
  }
</script>